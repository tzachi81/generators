Generator functions
--------------------
1.  Generator functions are iterator protocol functions that can break the 'Run-to-completion' paradigm.
    Their context will be saved across the program runtime.
    Calling a generator function does not execute its body immediately, but retuns a Generator object instead.
    to execute its body, you have to call the .next() method by its object reference.
    * show Example1 in generators.js

2.  generator functions can get and pass values with a two-way communication using [yield] and [next()] :
    "The yield keyword is used to pause and resume a generator function *()". (from: MDN web docs)
    yield returns an IteratorResult object with two properties, value and done:
        yield passes its next value to next() method or gets a value, if calling next() with an argument: next(arg).
    next() calls the first function body's yield expression and returns an object with the yielded value and done boolean value.
    * show Example2 in generators.js

3.  The yield* expression is used to delegate to another generator or iterable object.
    * show Example3 in generators.js
    
4.  A return statement in the function generator will make it finish (done: true).
    A throw exception in the function generator will make it finish (done: true).





# References:
    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
    https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435